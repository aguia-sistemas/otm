//------------------------------------------------------------------------------
// <auto-generated>
//		This code was generated from a template.
//		Manual changes to this file may cause unexpected behavior in your application.
//		Manual changes to this file will be overwritten if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
//Requires nuget Beffyman.AspNetCore.Client
using Beffyman.AspNetCore.Client.Authorization;
using Beffyman.AspNetCore.Client.Exceptions;
using Beffyman.AspNetCore.Client.GeneratorExtensions;
using Beffyman.AspNetCore.Client.Http;
using Beffyman.AspNetCore.Client.RequestModifiers;
using Beffyman.AspNetCore.Client.Serializers;
using Beffyman.AspNetCore.Client;
using Flurl.Http;
using Microsoft.Extensions.DependencyInjection;
using Otm.Shared.ContextConfig;
using Otm.Shared.Status;
using Otm.Shared;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Net;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text.Json;
using System.Threading.Tasks;
using System.Threading;
using System;

namespace Otm.Client.Api.Routes
{
	public static class StatusClientRoutes
	{
		public static string Get()
		{
			var controller = "Status";
			string url = $@"api/{controller}/";
			return url;
		}
	}

	public static class WeatherForecastClientRoutes
	{
		public static string Get()
		{
			var controller = "WeatherForecast";
			string url = $@"api/api/{controller}/";
			return url;
		}
	}
}

namespace Otm.Client.Api
{
#warning PLEASE MAKE A GITHUB REPO ISSUE ConfigController has failed generation with unexpected error :: System.MissingMethodException: Method not found: 'System.Collections.Generic.IDictionary`2<System.String,System.ValueTuple`2<System.String,System.String>> Beffyman.AspNetCore.Client.Generator.Framework.AspNetCoreHttp.Routes.HttpRoute.GetRouteParameters()'.     at Beffyman.AspNetCore.Client.Generator.Helpers.IsRouteParameter(String name, HttpRoute fullRouteTemplate)     at Beffyman.AspNetCore.Client.Generator.CSharp.AspNetCoreHttp.ParameterDefinition..ctor(ParameterSyntax parameter, HttpRoute fullRoute)     at Beffyman.AspNetCore.Client.Generator.Output.ClassParser.<>c__DisplayClass2_0.<ReadMethodAsHttpEndpoint>b__10(ParameterSyntax x)     at System.Linq.Enumerable.WhereSelectEnumerableIterator`2.MoveNext()     at System.Linq.Enumerable.WhereEnumerableIterator`1.MoveNext()     at System.Collections.Generic.List`1..ctor(IEnumerable`1 collection)     at System.Linq.Enumerable.ToList[TSource](IEnumerable`1 source)     at Beffyman.AspNetCore.Client.Generator.Output.ClassParser.ReadMethodAsHttpEndpoint(AspNetCoreHttpController parent, MethodDeclarationSyntax syntax)     at Beffyman.AspNetCore.Client.Generator.Output.ClassParser.<>c__DisplayClass1_0.<ReadClassAsHttpController>b__10(MethodDeclarationSyntax x)     at System.Linq.Enumerable.WhereSelectListIterator`2.MoveNext()     at System.Collections.Generic.List`1..ctor(IEnumerable`1 collection)     at System.Linq.Enumerable.ToList[TSource](IEnumerable`1 source)     at Beffyman.AspNetCore.Client.Generator.Output.ClassParser.ReadClassAsHttpController(ClassDeclarationSyntax syntax)
#warning PLEASE MAKE A GITHUB REPO ISSUE LogReaderController has failed generation with unexpected error :: System.MissingMethodException: Method not found: 'System.Collections.Generic.IDictionary`2<System.String,System.ValueTuple`2<System.String,System.String>> Beffyman.AspNetCore.Client.Generator.Framework.AspNetCoreHttp.Routes.HttpRoute.GetRouteParameters()'.     at Beffyman.AspNetCore.Client.Generator.Helpers.IsRouteParameter(String name, HttpRoute fullRouteTemplate)     at Beffyman.AspNetCore.Client.Generator.CSharp.AspNetCoreHttp.ParameterDefinition..ctor(ParameterSyntax parameter, HttpRoute fullRoute)     at Beffyman.AspNetCore.Client.Generator.Output.ClassParser.<>c__DisplayClass2_0.<ReadMethodAsHttpEndpoint>b__10(ParameterSyntax x)     at System.Linq.Enumerable.WhereSelectEnumerableIterator`2.MoveNext()     at System.Linq.Enumerable.WhereEnumerableIterator`1.MoveNext()     at System.Collections.Generic.List`1..ctor(IEnumerable`1 collection)     at System.Linq.Enumerable.ToList[TSource](IEnumerable`1 source)     at Beffyman.AspNetCore.Client.Generator.Output.ClassParser.ReadMethodAsHttpEndpoint(AspNetCoreHttpController parent, MethodDeclarationSyntax syntax)     at Beffyman.AspNetCore.Client.Generator.Output.ClassParser.<>c__DisplayClass1_0.<ReadClassAsHttpController>b__10(MethodDeclarationSyntax x)     at System.Linq.Enumerable.WhereSelectListIterator`2.MoveNext()     at System.Collections.Generic.List`1..ctor(IEnumerable`1 collection)     at System.Linq.Enumerable.ToList[TSource](IEnumerable`1 source)     at Beffyman.AspNetCore.Client.Generator.Output.ClassParser.ReadClassAsHttpController(ClassDeclarationSyntax syntax)
	public static class MyServiceClientInstaller
	{
		/// <summary>
		/// Register the autogenerated clients into the container with a lifecycle of scoped.
		/// </summary>
		/// <param name="services"></param>
		/// <param name="configure">Overrides for client configuration</param>
		/// <returns></returns>
		public static IServiceCollection AddMyServiceClients(this IServiceCollection services, Action<ClientConfiguration> configure)
		{
			var configuration = new ClientConfiguration();
			configuration.RegisterClientWrapperCreator<IMyServiceClient>(MyServiceClientWrapper.Create);
			configuration.UseClientWrapper<IMyServiceClientWrapper, MyServiceClientWrapper>((provider) => new MyServiceClientWrapper(provider.GetService<Func<IMyServiceClient, IFlurlClient>>(), configuration.GetSettings(), provider));
			configure?.Invoke(configuration);
			services.AddScoped<IMyServiceClientRepository, MyServiceClientRepository>();
			services.AddScoped<IStatusClient, StatusClient>();
			services.AddScoped<IWeatherForecastClient, WeatherForecastClient>();
			return configuration.ApplyConfiguration<IMyServiceClient>(services);
		}
	}

	public interface IMyServiceClientWrapper : IClientWrapper
	{
	}

	public class MyServiceClientWrapper : IMyServiceClientWrapper
	{
		public TimeSpan Timeout
		{
			get;
			internal set;
		}

		public IFlurlClient ClientWrapper
		{
			get;
			internal set;
		}

		public MyServiceClientWrapper(Func<IMyServiceClient, IFlurlClient> client, ClientSettings settings, IServiceProvider provider)
		{
			ClientWrapper = client(null);
			if (settings.BaseAddress != null)
			{
				ClientWrapper.BaseUrl = settings.BaseAddress(provider);
			}

			Timeout = settings.Timeout;
		}

		public static IMyServiceClientWrapper Create(Func<IMyServiceClient, IFlurlClient> client, ClientSettings settings, IServiceProvider provider)
		{
			return new MyServiceClientWrapper(client, settings, provider);
		}
	}

	public interface IMyServiceClient : IClient
	{
	}

	public interface IMyServiceClientRepository
	{
		IStatusClient Status
		{
			get;
		}

		IWeatherForecastClient WeatherForecast
		{
			get;
		}
	}

	internal class MyServiceClientRepository : IMyServiceClientRepository
	{
		protected readonly IServiceProvider _provider;
		private readonly Lazy<IStatusClient> lazy_Status;
		public IStatusClient Status => lazy_Status.Value;
		private readonly Lazy<IWeatherForecastClient> lazy_WeatherForecast;
		public IWeatherForecastClient WeatherForecast => lazy_WeatherForecast.Value;
		public MyServiceClientRepository(IServiceProvider provider)
		{
			this._provider = provider;
			this.lazy_Status = new Lazy<IStatusClient>(() => _provider.GetService<IStatusClient>());
			this.lazy_WeatherForecast = new Lazy<IWeatherForecastClient>(() => _provider.GetService<IWeatherForecastClient>());
		}
	}
}

namespace Otm.Client.Api
{
	public interface IStatusClient : IMyServiceClient
	{
		void Get(Action<OtmStatusDto> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage GetRaw(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		Task GetAsync(Action<OtmStatusDto> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> GetRawAsync(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
	}

	internal class StatusClient : IStatusClient
	{
		protected readonly IMyServiceClientWrapper Client;
		protected readonly IHttpOverride HttpOverride;
		protected readonly IHttpSerializer Serializer;
		protected readonly IHttpRequestModifier Modifier;
		public StatusClient(IMyServiceClientWrapper param_client, Func<IMyServiceClient, IHttpOverride> param_httpoverride, Func<IMyServiceClient, IHttpSerializer> param_serializer, Func<IMyServiceClient, IHttpRequestModifier> param_modifier)
		{
			Client = param_client;
			HttpOverride = param_httpoverride(this);
			Serializer = param_serializer(this);
			Modifier = param_modifier(this);
		}

		public void Get(Action<OtmStatusDto> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Status";
			string url = $@"api/{controller}/";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(Serializer.Deserialize<OtmStatusDto>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (!responseHandled)
			{
				throw new System.InvalidOperationException($"Response Status of {response.StatusCode} was not handled properly.");
			}

			return;
		}

		public HttpResponseMessage GetRaw(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Status";
			string url = $@"api/{controller}/";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async Task GetAsync(Action<OtmStatusDto> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Status";
			string url = $@"api/{controller}/";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(await Serializer.Deserialize<OtmStatusDto>(response.Content).ConfigureAwait(false));
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (!responseHandled)
			{
				throw new System.InvalidOperationException($"Response Status of {response.StatusCode} was not handled properly.");
			}

			return;
		}

		public async ValueTask<HttpResponseMessage> GetRawAsync(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Status";
			string url = $@"api/{controller}/";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}
	}

	public interface IWeatherForecastClient : IMyServiceClient
	{
		IEnumerable<WeatherForecast> Get(Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage GetRaw(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<IEnumerable<WeatherForecast>> GetAsync(Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> GetRawAsync(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
	}

	internal class WeatherForecastClient : IWeatherForecastClient
	{
		protected readonly IMyServiceClientWrapper Client;
		protected readonly IHttpOverride HttpOverride;
		protected readonly IHttpSerializer Serializer;
		protected readonly IHttpRequestModifier Modifier;
		public WeatherForecastClient(IMyServiceClientWrapper param_client, Func<IMyServiceClient, IHttpOverride> param_httpoverride, Func<IMyServiceClient, IHttpSerializer> param_serializer, Func<IMyServiceClient, IHttpRequestModifier> param_modifier)
		{
			Client = param_client;
			HttpOverride = param_httpoverride(this);
			Serializer = param_serializer(this);
			Modifier = param_modifier(this);
		}

		public IEnumerable<WeatherForecast> Get(Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "WeatherForecast";
			string url = $@"api/api/{controller}/";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(IEnumerable<WeatherForecast>);
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return Serializer.Deserialize<IEnumerable<WeatherForecast>>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult();
			}
			else
			{
				if (!responseHandled)
				{
					throw new System.InvalidOperationException($"Response Status of {response.StatusCode} was not handled properly.");
				}

				return default(IEnumerable<WeatherForecast>);
			}
		}

		public HttpResponseMessage GetRaw(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "WeatherForecast";
			string url = $@"api/api/{controller}/";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async ValueTask<IEnumerable<WeatherForecast>> GetAsync(Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "WeatherForecast";
			string url = $@"api/api/{controller}/";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(IEnumerable<WeatherForecast>);
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return await Serializer.Deserialize<IEnumerable<WeatherForecast>>(response.Content).ConfigureAwait(false);
			}
			else
			{
				if (!responseHandled)
				{
					throw new System.InvalidOperationException($"Response Status of {response.StatusCode} was not handled properly.");
				}

				return default(IEnumerable<WeatherForecast>);
			}
		}

		public async ValueTask<HttpResponseMessage> GetRawAsync(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "WeatherForecast";
			string url = $@"api/api/{controller}/";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}
	}
}