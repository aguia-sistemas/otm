//------------------------------------------------------------------------------
// <auto-generated>
//		This code was generated from a template.
//		Manual changes to this file may cause unexpected behavior in your application.
//		Manual changes to this file will be overwritten if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
//Requires nuget Beffyman.AspNetCore.Client
using Beffyman.AspNetCore.Client.Authorization;
using Beffyman.AspNetCore.Client.Exceptions;
using Beffyman.AspNetCore.Client.GeneratorExtensions;
using Beffyman.AspNetCore.Client.Http;
using Beffyman.AspNetCore.Client.RequestModifiers;
using Beffyman.AspNetCore.Client.Serializers;
using Beffyman.AspNetCore.Client;
using Flurl.Http;
using Microsoft.Extensions.DependencyInjection;
using Otm.Shared.ContextConfig;
using Otm.Shared;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Net;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text.Json;
using System.Threading.Tasks;
using System.Threading;
using System;

namespace Otm.Client.Api.Routes
{
	public static class EnviromentClientRoutes
	{
		public static string GetById(string id)
		{
			var controller = "Enviroment";
			string url = $@"{controller}/{id.EncodeForUrl()}";
			return url;
		}

		public static string Create()
		{
			var controller = "Enviroment";
			string url = $@"{controller}/";
			return url;
		}

		public static string Update(string id)
		{
			var controller = "Enviroment";
			string url = $@"{controller}/{id.EncodeForUrl()}";
			return url;
		}

		public static string Delete(string id)
		{
			var controller = "Enviroment";
			string url = $@"{controller}/{id.EncodeForUrl()}";
			return url;
		}
	}

	public static class LogClientRoutes
	{
		public static string Get()
		{
			var controller = "Log";
			string url = $@"{controller}/";
			return url;
		}
	}

	public static class WeatherForecastClientRoutes
	{
		public static string Get()
		{
			var controller = "WeatherForecast";
			string url = $@"{controller}/";
			return url;
		}
	}
}

namespace Otm.Client.Api
{
	public static class MyServiceClientInstaller
	{
		/// <summary>
		/// Register the autogenerated clients into the container with a lifecycle of scoped.
		/// </summary>
		/// <param name="services"></param>
		/// <param name="configure">Overrides for client configuration</param>
		/// <returns></returns>
		public static IServiceCollection AddMyServiceClients(this IServiceCollection services, Action<ClientConfiguration> configure)
		{
			var configuration = new ClientConfiguration();
			configuration.RegisterClientWrapperCreator<IMyServiceClient>(MyServiceClientWrapper.Create);
			configuration.UseClientWrapper<IMyServiceClientWrapper, MyServiceClientWrapper>((provider) => new MyServiceClientWrapper(provider.GetService<Func<IMyServiceClient, IFlurlClient>>(), configuration.GetSettings(), provider));
			configure?.Invoke(configuration);
			services.AddScoped<IMyServiceClientRepository, MyServiceClientRepository>();
			services.AddScoped<IEnviromentClient, EnviromentClient>();
			services.AddScoped<ILogClient, LogClient>();
			services.AddScoped<IWeatherForecastClient, WeatherForecastClient>();
			return configuration.ApplyConfiguration<IMyServiceClient>(services);
		}
	}

	public interface IMyServiceClientWrapper : IClientWrapper
	{
	}

	public class MyServiceClientWrapper : IMyServiceClientWrapper
	{
		public TimeSpan Timeout
		{
			get;
			internal set;
		}

		public IFlurlClient ClientWrapper
		{
			get;
			internal set;
		}

		public MyServiceClientWrapper(Func<IMyServiceClient, IFlurlClient> client, ClientSettings settings, IServiceProvider provider)
		{
			ClientWrapper = client(null);
			if (settings.BaseAddress != null)
			{
				ClientWrapper.BaseUrl = settings.BaseAddress(provider);
			}

			Timeout = settings.Timeout;
		}

		public static IMyServiceClientWrapper Create(Func<IMyServiceClient, IFlurlClient> client, ClientSettings settings, IServiceProvider provider)
		{
			return new MyServiceClientWrapper(client, settings, provider);
		}
	}

	public interface IMyServiceClient : IClient
	{
	}

	public interface IMyServiceClientRepository
	{
		IEnviromentClient Enviroment
		{
			get;
		}

		ILogClient Log
		{
			get;
		}

		IWeatherForecastClient WeatherForecast
		{
			get;
		}
	}

	internal class MyServiceClientRepository : IMyServiceClientRepository
	{
		protected readonly IServiceProvider _provider;
		private readonly Lazy<IEnviromentClient> lazy_Enviroment;
		public IEnviromentClient Enviroment => lazy_Enviroment.Value;
		private readonly Lazy<ILogClient> lazy_Log;
		public ILogClient Log => lazy_Log.Value;
		private readonly Lazy<IWeatherForecastClient> lazy_WeatherForecast;
		public IWeatherForecastClient WeatherForecast => lazy_WeatherForecast.Value;
		public MyServiceClientRepository(IServiceProvider provider)
		{
			this._provider = provider;
			this.lazy_Enviroment = new Lazy<IEnviromentClient>(() => _provider.GetService<IEnviromentClient>());
			this.lazy_Log = new Lazy<ILogClient>(() => _provider.GetService<ILogClient>());
			this.lazy_WeatherForecast = new Lazy<IWeatherForecastClient>(() => _provider.GetService<IWeatherForecastClient>());
		}
	}
}

namespace Otm.Client.Api
{
	public interface IEnviromentClient : IMyServiceClient
	{
		void GetById(string id, Action<RootConfig> OKCallback = null, Action NotFoundCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage GetByIdRaw(string id, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		Task GetByIdAsync(string id, Action<RootConfig> OKCallback = null, Action NotFoundCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> GetByIdRawAsync(string id, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		void Create(RootConfig config, Action<RootConfig> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage CreateRaw(RootConfig config, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		Task CreateAsync(RootConfig config, Action<RootConfig> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> CreateRawAsync(RootConfig config, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		void Update(RootConfig config, string id, Action<RootConfig> OKCallback = null, Action NotFoundCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage UpdateRaw(RootConfig config, string id, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		Task UpdateAsync(RootConfig config, string id, Action<RootConfig> OKCallback = null, Action NotFoundCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> UpdateRawAsync(RootConfig config, string id, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		void Delete(string id, Action OKCallback = null, Action NotFoundCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage DeleteRaw(string id, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		Task DeleteAsync(string id, Action OKCallback = null, Action NotFoundCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> DeleteRawAsync(string id, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
	}

	internal class EnviromentClient : IEnviromentClient
	{
		protected readonly IMyServiceClientWrapper Client;
		protected readonly IHttpOverride HttpOverride;
		protected readonly IHttpSerializer Serializer;
		protected readonly IHttpRequestModifier Modifier;
		public EnviromentClient(IMyServiceClientWrapper param_client, Func<IMyServiceClient, IHttpOverride> param_httpoverride, Func<IMyServiceClient, IHttpSerializer> param_serializer, Func<IMyServiceClient, IHttpRequestModifier> param_modifier)
		{
			Client = param_client;
			HttpOverride = param_httpoverride(this);
			Serializer = param_serializer(this);
			Modifier = param_modifier(this);
		}

		public void GetById(string id, Action<RootConfig> OKCallback = null, Action NotFoundCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Enviroment";
			string url = $@"{controller}/{id.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(Serializer.Deserialize<RootConfig>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (NotFoundCallback != null && NotFoundCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for NotFoundCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.NotFound)
			{
				if (NotFoundCallback != null)
				{
					responseHandled = true;
					NotFoundCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (!responseHandled)
			{
				throw new System.InvalidOperationException($"Response Status of {response.StatusCode} was not handled properly.");
			}

			return;
		}

		public HttpResponseMessage GetByIdRaw(string id, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Enviroment";
			string url = $@"{controller}/{id.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async Task GetByIdAsync(string id, Action<RootConfig> OKCallback = null, Action NotFoundCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Enviroment";
			string url = $@"{controller}/{id.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(await Serializer.Deserialize<RootConfig>(response.Content).ConfigureAwait(false));
				}
			}

			if (NotFoundCallback != null && NotFoundCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for NotFoundCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.NotFound)
			{
				if (NotFoundCallback != null)
				{
					responseHandled = true;
					NotFoundCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (!responseHandled)
			{
				throw new System.InvalidOperationException($"Response Status of {response.StatusCode} was not handled properly.");
			}

			return;
		}

		public async ValueTask<HttpResponseMessage> GetByIdRawAsync(string id, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Enviroment";
			string url = $@"{controller}/{id.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public void Create(RootConfig config, Action<RootConfig> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Enviroment";
			string url = $@"{controller}/";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(Serializer.Serialize(config), cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, config, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(Serializer.Deserialize<RootConfig>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (!responseHandled)
			{
				throw new System.InvalidOperationException($"Response Status of {response.StatusCode} was not handled properly.");
			}

			return;
		}

		public HttpResponseMessage CreateRaw(RootConfig config, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Enviroment";
			string url = $@"{controller}/";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(Serializer.Serialize(config), cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, config, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async Task CreateAsync(RootConfig config, Action<RootConfig> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Enviroment";
			string url = $@"{controller}/";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(Serializer.Serialize(config), cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, config, response, cancellationToken).ConfigureAwait(false);
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(await Serializer.Deserialize<RootConfig>(response.Content).ConfigureAwait(false));
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (!responseHandled)
			{
				throw new System.InvalidOperationException($"Response Status of {response.StatusCode} was not handled properly.");
			}

			return;
		}

		public async ValueTask<HttpResponseMessage> CreateRawAsync(RootConfig config, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Enviroment";
			string url = $@"{controller}/";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(Serializer.Serialize(config), cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, config, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public void Update(RootConfig config, string id, Action<RootConfig> OKCallback = null, Action NotFoundCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Enviroment";
			string url = $@"{controller}/{id.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Put, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PutAsync(Serializer.Serialize(config), cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Put, url, config, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(Serializer.Deserialize<RootConfig>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (NotFoundCallback != null && NotFoundCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for NotFoundCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.NotFound)
			{
				if (NotFoundCallback != null)
				{
					responseHandled = true;
					NotFoundCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (!responseHandled)
			{
				throw new System.InvalidOperationException($"Response Status of {response.StatusCode} was not handled properly.");
			}

			return;
		}

		public HttpResponseMessage UpdateRaw(RootConfig config, string id, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Enviroment";
			string url = $@"{controller}/{id.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Put, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PutAsync(Serializer.Serialize(config), cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Put, url, config, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async Task UpdateAsync(RootConfig config, string id, Action<RootConfig> OKCallback = null, Action NotFoundCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Enviroment";
			string url = $@"{controller}/{id.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Put, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PutAsync(Serializer.Serialize(config), cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Put, url, config, response, cancellationToken).ConfigureAwait(false);
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(await Serializer.Deserialize<RootConfig>(response.Content).ConfigureAwait(false));
				}
			}

			if (NotFoundCallback != null && NotFoundCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for NotFoundCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.NotFound)
			{
				if (NotFoundCallback != null)
				{
					responseHandled = true;
					NotFoundCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (!responseHandled)
			{
				throw new System.InvalidOperationException($"Response Status of {response.StatusCode} was not handled properly.");
			}

			return;
		}

		public async ValueTask<HttpResponseMessage> UpdateRawAsync(RootConfig config, string id, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Enviroment";
			string url = $@"{controller}/{id.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Put, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PutAsync(Serializer.Serialize(config), cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Put, url, config, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public void Delete(string id, Action OKCallback = null, Action NotFoundCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Enviroment";
			string url = $@"{controller}/{id.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Delete, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().DeleteAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Delete, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke();
				}
			}

			if (NotFoundCallback != null && NotFoundCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for NotFoundCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.NotFound)
			{
				if (NotFoundCallback != null)
				{
					responseHandled = true;
					NotFoundCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (!responseHandled)
			{
				throw new System.InvalidOperationException($"Response Status of {response.StatusCode} was not handled properly.");
			}

			return;
		}

		public HttpResponseMessage DeleteRaw(string id, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Enviroment";
			string url = $@"{controller}/{id.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Delete, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().DeleteAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Delete, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async Task DeleteAsync(string id, Action OKCallback = null, Action NotFoundCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Enviroment";
			string url = $@"{controller}/{id.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Delete, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().DeleteAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Delete, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke();
				}
			}

			if (NotFoundCallback != null && NotFoundCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for NotFoundCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.NotFound)
			{
				if (NotFoundCallback != null)
				{
					responseHandled = true;
					NotFoundCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (!responseHandled)
			{
				throw new System.InvalidOperationException($"Response Status of {response.StatusCode} was not handled properly.");
			}

			return;
		}

		public async ValueTask<HttpResponseMessage> DeleteRawAsync(string id, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Enviroment";
			string url = $@"{controller}/{id.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Delete, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().DeleteAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Delete, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}
	}

	public interface ILogClient : IMyServiceClient
	{
		void Get(Action<List<string>> OKCallback = null, Action NotFoundCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage GetRaw(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		Task GetAsync(Action<List<string>> OKCallback = null, Action NotFoundCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> GetRawAsync(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
	}

	internal class LogClient : ILogClient
	{
		protected readonly IMyServiceClientWrapper Client;
		protected readonly IHttpOverride HttpOverride;
		protected readonly IHttpSerializer Serializer;
		protected readonly IHttpRequestModifier Modifier;
		public LogClient(IMyServiceClientWrapper param_client, Func<IMyServiceClient, IHttpOverride> param_httpoverride, Func<IMyServiceClient, IHttpSerializer> param_serializer, Func<IMyServiceClient, IHttpRequestModifier> param_modifier)
		{
			Client = param_client;
			HttpOverride = param_httpoverride(this);
			Serializer = param_serializer(this);
			Modifier = param_modifier(this);
		}

		public void Get(Action<List<string>> OKCallback = null, Action NotFoundCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Log";
			string url = $@"{controller}/";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(Serializer.Deserialize<List<string>>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (NotFoundCallback != null && NotFoundCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for NotFoundCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.NotFound)
			{
				if (NotFoundCallback != null)
				{
					responseHandled = true;
					NotFoundCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (!responseHandled)
			{
				throw new System.InvalidOperationException($"Response Status of {response.StatusCode} was not handled properly.");
			}

			return;
		}

		public HttpResponseMessage GetRaw(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Log";
			string url = $@"{controller}/";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async Task GetAsync(Action<List<string>> OKCallback = null, Action NotFoundCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Log";
			string url = $@"{controller}/";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(await Serializer.Deserialize<List<string>>(response.Content).ConfigureAwait(false));
				}
			}

			if (NotFoundCallback != null && NotFoundCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for NotFoundCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.NotFound)
			{
				if (NotFoundCallback != null)
				{
					responseHandled = true;
					NotFoundCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (!responseHandled)
			{
				throw new System.InvalidOperationException($"Response Status of {response.StatusCode} was not handled properly.");
			}

			return;
		}

		public async ValueTask<HttpResponseMessage> GetRawAsync(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Log";
			string url = $@"{controller}/";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}
	}

	public interface IWeatherForecastClient : IMyServiceClient
	{
		IEnumerable<WeatherForecast> Get(Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage GetRaw(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<IEnumerable<WeatherForecast>> GetAsync(Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> GetRawAsync(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
	}

	internal class WeatherForecastClient : IWeatherForecastClient
	{
		protected readonly IMyServiceClientWrapper Client;
		protected readonly IHttpOverride HttpOverride;
		protected readonly IHttpSerializer Serializer;
		protected readonly IHttpRequestModifier Modifier;
		public WeatherForecastClient(IMyServiceClientWrapper param_client, Func<IMyServiceClient, IHttpOverride> param_httpoverride, Func<IMyServiceClient, IHttpSerializer> param_serializer, Func<IMyServiceClient, IHttpRequestModifier> param_modifier)
		{
			Client = param_client;
			HttpOverride = param_httpoverride(this);
			Serializer = param_serializer(this);
			Modifier = param_modifier(this);
		}

		public IEnumerable<WeatherForecast> Get(Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "WeatherForecast";
			string url = $@"{controller}/";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(IEnumerable<WeatherForecast>);
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return Serializer.Deserialize<IEnumerable<WeatherForecast>>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult();
			}
			else
			{
				if (!responseHandled)
				{
					throw new System.InvalidOperationException($"Response Status of {response.StatusCode} was not handled properly.");
				}

				return default(IEnumerable<WeatherForecast>);
			}
		}

		public HttpResponseMessage GetRaw(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "WeatherForecast";
			string url = $@"{controller}/";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async ValueTask<IEnumerable<WeatherForecast>> GetAsync(Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "WeatherForecast";
			string url = $@"{controller}/";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(IEnumerable<WeatherForecast>);
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return await Serializer.Deserialize<IEnumerable<WeatherForecast>>(response.Content).ConfigureAwait(false);
			}
			else
			{
				if (!responseHandled)
				{
					throw new System.InvalidOperationException($"Response Status of {response.StatusCode} was not handled properly.");
				}

				return default(IEnumerable<WeatherForecast>);
			}
		}

		public async ValueTask<HttpResponseMessage> GetRawAsync(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "WeatherForecast";
			string url = $@"{controller}/";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}
	}
}